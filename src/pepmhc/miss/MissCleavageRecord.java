
package pepmhc.miss;

import java.util.Collection;
import java.util.Comparator;
import java.util.HashSet;
import java.util.Set;

import jam.io.Delimiter;
import jam.math.Probability;
import jam.math.UnitIndex;
import jam.math.UnitIndexRange;
import jam.report.LineBuilder;

import jene.hugo.HugoSymbol;
import jene.neo.NeoPeptide;
import jene.neo.SelfPeptide;
import jene.peptide.Peptide;
import jene.peptide.ProteinChange;
import jene.tcga.TumorBarcode;
import jene.tcga.TumorGeneRecord;
import jene.tcga.TumorGeneRecordBase;

import pepmhc.affy.Affinity;

/**
 * Associates a missense mutation with a self-peptide where it may
 * occur, the neo-peptide that will be produced, and the probability
 * that the neo-peptide will be generated by proteasomal cleavage.
 */
public class MissCleavageRecord extends TumorGeneRecordBase {
    private final ProteinChange proteinChange;

    private final UnitIndex neoPepMissPos;
    private final UnitIndexRange neoPepRange;

    private final NeoPeptide  neoPeptide;
    private final SelfPeptide selfPeptide;

    private final Probability neoCleaveProb;
    private final Probability selfCleaveProb;

    private MissCleavageRecord(TumorBarcode   tumorBarcode,
                               HugoSymbol     hugoSymbol,
                               ProteinChange  proteinChange,
                               UnitIndex      neoPepMissPos,
                               UnitIndexRange neoPepRange,
                               NeoPeptide     neoPeptide,
                               SelfPeptide    selfPeptide,
                               Probability    neoCleaveProb,
                               Probability    selfCleaveProb) {
        super(tumorBarcode, hugoSymbol);

        this.proteinChange = proteinChange;

        this.neoPepRange = neoPepRange;
        this.neoPepMissPos = neoPepMissPos;

        this.neoPeptide = neoPeptide;
        this.selfPeptide = selfPeptide;

        this.neoCleaveProb = neoCleaveProb;
        this.selfCleaveProb = selfCleaveProb;
    }

    /**
     * The standard delimiter for flat files containing cleavage
     * records.
     */
    public static final Delimiter DELIM = Delimiter.TAB;

    /**
     * A comparator that orders records by tumor barcode first, HUGO
     * symbol second, mutation position in the native protein third,
     * and neo-peptide mutation position fourth.
     */
    public static final Comparator<MissCleavageRecord> COMPARATOR =
        new Comparator<MissCleavageRecord>() {
            @Override public int compare(MissCleavageRecord rec1, MissCleavageRecord rec2) {
                int barcodeSymbolCmp = BARCODE_SYMBOL_COMPARATOR.compare(rec1, rec2);

                if (barcodeSymbolCmp != 0)
                    return barcodeSymbolCmp;

                int proteinChangeCmp =
                    ProteinChange.POSITION_COMPARATOR.compare(rec1.getProteinChange(),
                                                              rec2.getProteinChange());

                if (proteinChangeCmp != 0)
                    return proteinChangeCmp;
                else
                    return rec1.neoPepMissPos.compareTo(rec2.neoPepMissPos);
            }
        };

    /**
     * Returns a cleavage record with fixed components.
     *
     * @param tumorBarcode the tumor where the mutation occurred.
     *
     * @param hugoSymbol the HUGO symbol of the mutated gene.
     *
     * @param proteinChange the missense mutation that occurred.
     *
     * @param neoPepMissPos the position of the missense mutation
     * within the neo-peptide fragment (an index between 1 and the
     * length of the fragment).
     *
     * @param neoPepRange the position of the neo-peptide relative
     * to the complete native protein structure.
     *
     * @param neoPeptide the neo-peptide generated by somatic
     * mutation.
     *
     * @param selfPeptide the germline self-peptide.
     *
     * @param neoCleaveProb the probability that the neo-peptide
     * would be generated by proteasomal cleavage.
     *
     * @param selfCleaveProb the probability that the self-peptide
     * would be generated by proteasomal cleavage.
     *
     * @return the cleavage record with the specified components.
     */
    public static MissCleavageRecord create(TumorBarcode   tumorBarcode,
                                            HugoSymbol     hugoSymbol,
                                            ProteinChange  proteinChange,
                                            UnitIndex      neoPepMissPos,
                                            UnitIndexRange neoPepRange,
                                            NeoPeptide     neoPeptide,
                                            SelfPeptide    selfPeptide,
                                            Probability    neoCleaveProb,
                                            Probability    selfCleaveProb) {
        return new MissCleavageRecord(tumorBarcode,
                                      hugoSymbol,
                                      proteinChange,
                                      neoPepMissPos,
                                      neoPepRange,
                                      neoPeptide,
                                      selfPeptide,
                                      neoCleaveProb,
                                      selfCleaveProb);
    }

    /**
     * Extracts the neo-peptides and self-peptides from a collection
     * of cleavage records.
     *
     * @param records the cleavage records to process.
     *
     * @return a set containin the unique peptides (neo and self)
     * contained in the input cleavage records.
     */
    public static Set<Peptide> extractPeptides(Collection<MissCleavageRecord> records) {
        Set<Peptide> peptides = new HashSet<Peptide>();

        for (MissCleavageRecord record : records) {
            peptides.add(record.getNeoPeptide());
            peptides.add(record.getSelfPeptide());
        }

        return peptides;
    }

    /**
     * Returns the header line for flat files containing cleavage
     * records.
     *
     * @return the header line for flat files containing cleavage
     * records.
     */
    public static String header() {
        return header(DELIM);
    }

    /**
     * Returns the header line for flat files containing cleavage
     * records.
     *
     * @param delimiter the flat file field delimiter.
     *
     * @return the header line for flat files containing cleavage
     * records.
     */
    public static String header(Delimiter delimiter) {
        LineBuilder builder = new LineBuilder(delimiter);

        builder.append(TumorBarcode.COLUMN_NAME);
        builder.append(HugoSymbol.COLUMN_NAME);
        builder.append(ProteinChange.COLUMN_NAME);
        builder.append("Neo_Peptide_Missense_Pos");
        builder.append("Neo_Peptide_Range_Lower");
        builder.append("Neo_Peptide_Range_Upper");
        builder.append("Neo_Peptide");
        builder.append("Self_Peptide");
        builder.append("Neo_Peptide_Cleave_Prob");
        builder.append("Self_Peptide_Cleave_Prob");

        return builder.toString();
    }

    /**
     * Creates a new cleavage record by parsing a delimited line from
     * a flat file.
     *
     * @param line the line to parse.
     *
     * @return the cleavage record encoded in the specified line.
     *
     * @throws RuntimeException unless the line contains a properly
     * formatted cleavage record.
     */
    public static MissCleavageRecord parse(String line) {
        return parse(DELIM.split(line, 10), 0);
    }

    /**
     * Creates a new cleavage record by parsing an array of fields.
     *
     * <p>The fields must start at index {@code offset} and be
     * arranged sequentially and contiguously.
     *
     * @param fields an array of individual fields extracted from
     * a flat file.
     *
     * @param offset the index of the tumor barcode in the input
     * array.
     *
     * @return the cleavage record encoded in the
     * specified fields.
     *
     * @throws RuntimeException unless the fields define a valid
     * cleavage record.
     */
    public static MissCleavageRecord parse(String[] fields, int offset) {
        TumorBarcode  tumorBarcode   = TumorBarcode.instance(fields[offset]);
        HugoSymbol    hugoSymbol     = HugoSymbol.instance(fields[offset + 1]);
        ProteinChange proteinChange  = ProteinChange.parse(fields[offset + 2]);
        int           missensePos    = Integer.parseInt(fields[offset + 3]);
        int           rangeLower     = Integer.parseInt(fields[offset + 4]);
        int           rangeUpper     = Integer.parseInt(fields[offset + 5]);
        NeoPeptide    neoPeptide     = NeoPeptide.instance(fields[offset + 6]);
        SelfPeptide   selfPeptide    = SelfPeptide.instance(fields[offset + 7]);
        Probability   neoCleaveProb  = Probability.parse(fields[offset + 8]);
        Probability   selfCleaveProb = Probability.parse(fields[offset + 9]);

        return create(tumorBarcode,
                      hugoSymbol,
                      proteinChange,
                      UnitIndex.instance(missensePos),
                      UnitIndexRange.instance(rangeLower, rangeUpper),
                      neoPeptide,
                      selfPeptide,
                      neoCleaveProb,
                      selfCleaveProb);
    }

    /**
     * Formats this record for output to a delimited flat file.
     *
     * @return a string containing the formatted text.
     */
    public String format() {
        return format(DELIM);
    }

    /**
     * Formats this record for output to a delimited flat file.
     *
     * @param delimiter the flat file field delimiter.
     *
     * @return a string containing the formatted text.
     */
    public String format(Delimiter delimiter) {
        LineBuilder builder = new LineBuilder(delimiter);

        builder.append(tumorBarcode.getKey());
        builder.append(hugoSymbol.getKey());
        builder.append(proteinChange.format());
        builder.append(neoPepMissPos.getUnitIndex());
        builder.append(neoPepRange.lower());
        builder.append(neoPepRange.upper());
        builder.append(neoPeptide.getPeptide().formatString());
        builder.append(selfPeptide.getPeptide().formatString());
        builder.append(neoCleaveProb.doubleValue(), "%.4f");
        builder.append(selfCleaveProb.doubleValue(), "%.4f");

        return builder.toString();
    }

    /**
     * Returns the missense mutation that occurred.
     *
     * @return the missense mutation that occurred.
     */
    public ProteinChange getProteinChange() {
        return proteinChange;
    }

    /**
     * Returns the neo-peptide derived from the self-peptide by
     * somatic mutation.
     *
     * @return the neo-peptide derived from the self-peptide by
     * somatic mutation.
     */
    public Peptide getNeoPeptide() {
        return neoPeptide.getPeptide();
    }

    /**
     * Returns the probability that the neo-peptide would be generated
     * by proteasomal cleavage.
     *
     * @return the probability that the neo-peptide would be generated
     * by proteasomal cleavage.
     */
    public Probability getNeoPeptideCleavageProb() {
        return neoCleaveProb;
    }

    /**
     * Returns the position of the missense mutation within the
     * neo-peptide fragment (an index between 1 and the length
     * of the neo-peptide).
     *
     * @return the position of the missense mutation within the
     * neo-peptide fragment.
     */
    public UnitIndex getNeoPeptideMissensePosition() {
        return neoPepMissPos;
    }

    /**
     * Returns the position of the neo-peptide relative to the
     * complete native protein structure.
     *
     * @return the position of the neo-peptide relative to the
     * complete native protein structure.
     */
    public UnitIndexRange getNeoPeptideNativeRange() {
        return neoPepRange;
    }

    /**
     * Returns the self-peptide derived from the germline genome.
     *
     * @return the self-peptide derived from the germline genome.
     */
    public Peptide getSelfPeptide() {
        return selfPeptide.getPeptide();
    }

    /**
     * Returns the probability that the self-peptide would be generated
     * by proteasomal cleavage.
     *
     * @return the probability that the self-peptide would be generated
     * by proteasomal cleavage.
     */
    public Probability getSelfPeptideCleavageProb() {
        return selfCleaveProb;
    }

    @Override public String toString() {
        LineBuilder builder = new LineBuilder("\n");

        builder.append("MissCleavageRecord:");
        builder.append("  tumorBarcode   = " + tumorBarcode.getKey());
        builder.append("  hugoSymbol     = " + hugoSymbol.getKey());
        builder.append("  proteinChange  = " + proteinChange.format());
        builder.append("  neoPepMissPos  = " + Integer.toString(neoPepMissPos.getUnitIndex()));
        builder.append("  neoPepRange    = " + neoPepRange.format());
        builder.append("  neoPeptide     = " + neoPeptide.getPeptide().formatString());
        builder.append("  selfPeptide    = " + selfPeptide.getPeptide().formatString());
        builder.append("  neoCleaveProb  = " + neoCleaveProb);
        builder.append("  selfCleaveProb = " + selfCleaveProb);

        return builder.toString();
    }
}

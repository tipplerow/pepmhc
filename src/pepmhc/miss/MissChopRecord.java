
package pepmhc.miss;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Comparator;

import jam.io.Delimiter;
import jam.lang.JamException;
import jam.math.Probability;
import jam.math.UnitIndex;
import jam.math.UnitIndexRange;
import jam.report.LineBuilder;

import jene.hugo.HugoSymbol;
import jene.neo.NeoPeptide;
import jene.neo.SelfPeptide;
import jene.peptide.Peptide;
import jene.peptide.ProteinChange;
import jene.tcga.TumorBarcode;
import jene.tcga.TumorGeneRecord;

import pepmhc.affy.Affinity;

/**
 * Associates a missense mutation with a neo-peptide that it
 * produces and the probability that the neo-peptide peptide
 * will be generated by proteasomal cleavage.
 */
public class MissChopRecord extends TumorGeneRecord {
    private final ProteinChange proteinChange;

    private final UnitIndex neoPepMissPos;
    private final UnitIndexRange neoPepRange;

    private final NeoPeptide  neoPeptide;
    private final SelfPeptide selfPeptide;

    private final Probability neoCleaveProb;
    private final Probability selfCleaveProb;

    private MissChopRecord(TumorBarcode   tumorBarcode,
                           HugoSymbol     hugoSymbol,
                           ProteinChange  proteinChange,
                           UnitIndex      neoPepMissPos,
                           UnitIndexRange neoPepRange,
                           NeoPeptide     neoPeptide,
                           SelfPeptide    selfPeptide,
                           Probability    neoCleaveProb,
                           Probability    selfCleaveProb) {
        super(tumorBarcode, hugoSymbol);
        this.proteinChange = proteinChange;

        this.neoPepRange = neoPepRange;
        this.neoPepMissPos = neoPepMissPos;

        this.neoPeptide = neoPeptide;
        this.selfPeptide = selfPeptide;

        this.neoCleaveProb = neoCleaveProb;
        this.selfCleaveProb = selfCleaveProb;
    }

    /**
     * The standard delimiter for flat files containing missense
     * neopeptide records.
     */
    public static final Delimiter DELIM = Delimiter.TAB;

    /**
     * A comparator that orders records by tumor barcode first, HUGO
     * symbol second, mutation position in the native protein third,
     * and neo-peptide mutation position fourth.
     */
    public static final Comparator<MissChopRecord> COMPARATOR =
        new Comparator<MissChopRecord>() {
            @Override public int compare(MissChopRecord rec1, MissChopRecord rec2) {
                int barcodeSymbolCmp = BARCODE_SYMBOL_COMPARATOR.compare(rec1, rec2);

                if (barcodeSymbolCmp != 0)
                    return barcodeSymbolCmp;

                int proteinChangeCmp =
                    ProteinChange.POSITION_COMPARATOR.compare(rec1.getProteinChange(),
                                                              rec2.getProteinChange());

                if (proteinChangeCmp != 0)
                    return proteinChangeCmp;
                else
                    return rec1.neoPepMissPos.compareTo(rec2.neoPepMissPos);
            }
        };

    /**
     * Returns a neo-peptide missense record with fixed components.
     *
     * @param tumorBarcode the tumor where the mutation occurred.
     *
     * @param hugoSymbol the HUGO symbol of the mutated gene.
     *
     * @param proteinChange the missense mutation that occurred.
     *
     * @param neoPepMissPos the position of the missense mutation
     * within the neo-peptide fragment (an index between 1 and the
     * length of the fragment).
     *
     * @param neoPepRange the position of the neo-peptide relative
     * to the complete native protein structure.
     *
     * @param neoPeptide the neo-peptide generated by somatic
     * mutation.
     *
     * @param selfPeptide the germline self-peptide.
     *
     * @param neoCleaveProb the probability that the neo-peptide
     * would be generated by proteasomal cleavage.
     *
     * @param selfCleaveProb the probability that the self-peptide
     * would be generated by proteasomal cleavage.
     *
     * @return the neo-peptide missense record with the specified
     * components.
     */
    public static MissChopRecord create(TumorBarcode   tumorBarcode,
                                        HugoSymbol     hugoSymbol,
                                        ProteinChange  proteinChange,
                                        UnitIndex      neoPepMissPos,
                                        UnitIndexRange neoPepRange,
                                        NeoPeptide     neoPeptide,
                                        SelfPeptide    selfPeptide,
                                        Probability    neoCleaveProb,
                                        Probability    selfCleaveProb) {
        return new MissChopRecord(tumorBarcode,
                                  hugoSymbol,
                                  proteinChange,
                                  neoPepMissPos,
                                  neoPepRange,
                                  neoPeptide,
                                  selfPeptide,
                                  neoCleaveProb,
                                  selfCleaveProb);
    }                                            

    /**
     * Returns the header line for flat files containing neo-peptide
     * missense records.
     *
     * @return the header line for flat files containing neo-peptide
     * missense records.
     */
    public static String header() {
        return header(DELIM);
    }

    /**
     * Returns the header line for flat files containing neo-peptide
     * missense records.
     *
     * @param delimiter the flat file field delimiter.
     *
     * @return the header line for flat files containing neo-peptide
     * missense records.
     */
    public static String header(Delimiter delimiter) {
        LineBuilder builder = new LineBuilder(delimiter);

        builder.append(TumorBarcode.COLUMN_NAME);
        builder.append(HugoSymbol.COLUMN_NAME);
        builder.append(ProteinChange.COLUMN_NAME);
        builder.append("Neo_Peptide_Missense_Pos");
        builder.append("Neo_Peptide_Range_Lower");
        builder.append("Neo_Peptide_Range_Upper");
        builder.append("Neo_Peptide");
        builder.append("Self_Peptide");
        builder.append("Neo_Peptide_Cleave_Prob");
        builder.append("Self_Peptide_Cleave_Prob");

        return builder.toString();
    }

    /**
     * Creates a new neo-peptide missense record by parsing a
     * delimited line from a flat file.
     *
     * @param line the line to parse.
     *
     * @return the neo-peptide missense record encoded in the
     * specified line.
     *
     * @throws RuntimeException unless the line contains a properly
     * formatted neo-peptide missense record.
     */
    public static MissChopRecord parse(String line) {
        return parse(DELIM.split(line, 10), 0);
    }

    /**
     * Creates a new neo-peptide missense record by parsing an array
     * of fields.
     *
     * <p>The fields must start at index {@code offset} and be
     * arranged sequentially and contiguously.
     *
     * @param fields an array of individual fields extracted from
     * a flat file.
     *
     * @param offset the index of the tumor barcode in the input
     * array.
     *
     * @return the neo-peptide missense record encoded in the
     * specified fields.
     *
     * @throws RuntimeException unless the fields define a valid
     * neo-peptide missense record.
     */
    public static MissChopRecord parse(String[] fields, int offset) {
        TumorBarcode  tumorBarcode   = TumorBarcode.instance(fields[offset]);
        HugoSymbol    hugoSymbol     = HugoSymbol.instance(fields[offset + 1]);
        ProteinChange proteinChange  = ProteinChange.parse(fields[offset + 2]);
        int           missensePos    = Integer.parseInt(fields[offset + 3]);
        int           rangeLower     = Integer.parseInt(fields[offset + 4]);
        int           rangeUpper     = Integer.parseInt(fields[offset + 5]);
        NeoPeptide    neoPeptide     = NeoPeptide.instance(fields[offset + 6]);
        SelfPeptide   selfPeptide    = SelfPeptide.instance(fields[offset + 7]);
        Probability   neoCleaveProb  = Probability.parse(fields[offset + 8]);
        Probability   selfCleaveProb = Probability.parse(fields[offset + 9]);

        return create(tumorBarcode,
                      hugoSymbol,
                      proteinChange,
                      UnitIndex.instance(missensePos),
                      UnitIndexRange.instance(rangeLower, rangeUpper),
                      neoPeptide,
                      selfPeptide,
                      neoCleaveProb,
                      selfCleaveProb);
    }

    /**
     * Extracts the peptides from a collection of chop records.
     *
     * @param chopRecords the neo-peptide missense records to process.
     *
     * @return the neo-peptides and self-peptides contained in the
     * specified records (in no particular order).
     */
    /*
    public static Collection<Peptide> peptides(Collection<MissChopRecord> chopRecords) {
        Collection<Peptide> peptides =
            new ArrayList<Peptide>(2 * chopRecords.size());

        for (MissChopRecord record : chopRecords) {
            peptides.add(record.getNeoPeptide());
            peptides.add(record.getSelfPeptide());
        }

        return peptides;
    }
    */

    /**
     * Formats this record for output to a delimited flat file.
     *
     * @return a string containing the formatted text.
     */
    public String format() {
        return format(DELIM);
    }

    /**
     * Formats this record for output to a delimited flat file.
     *
     * @param delimiter the flat file field delimiter.
     *
     * @return a string containing the formatted text.
     */
    public String format(Delimiter delimiter) {
        LineBuilder builder = new LineBuilder(delimiter);

        builder.append(tumorBarcode.getKey());
        builder.append(hugoSymbol.getKey());
        builder.append(proteinChange.format());
        builder.append(neoPepMissPos.getUnitIndex());
        builder.append(neoPepRange.lower());
        builder.append(neoPepRange.upper());
        builder.append(neoPeptide.getPeptide().formatString());
        builder.append(selfPeptide.getPeptide().formatString());
        builder.append(neoCleaveProb.doubleValue(), "%.4f");
        builder.append(selfCleaveProb.doubleValue(), "%.4f");

        return builder.toString();
    }

    /**
     * Returns the missense mutation that occurred.
     *
     * @return the missense mutation that occurred.
     */
    public ProteinChange getProteinChange() {
        return proteinChange;
    }

    /**
     * Returns the neo-peptide derived from the self-peptide by
     * somatic mutation.
     *
     * @return the neo-peptide derived from the self-peptide by
     * somatic mutation.
     */
    public Peptide getNeoPeptide() {
        return neoPeptide.getPeptide();
    }

    /**
     * Returns the probability that the neo-peptide would be generated
     * by proteasomal cleavage.
     *
     * @return the probability that the neo-peptide would be generated
     * by proteasomal cleavage.
     */
    public Probability getNeoPeptideCleavageProb() {
        return neoCleaveProb;
    }

    /**
     * Returns the position of the missense mutation within the
     * neo-peptide fragment (an index between 1 and the length
     * of the neo-peptide).
     *
     * @return the position of the missense mutation within the
     * neo-peptide fragment.
     */
    public UnitIndex getNeoPeptideMissensePosition() {
        return neoPepMissPos;
    }

    /**
     * Returns the position of the neo-peptide relative to the
     * complete native protein structure.
     *
     * @return the position of the neo-peptide relative to the
     * complete native protein structure.
     */
    public UnitIndexRange getNeoPeptideNativeRange() {
        return neoPepRange;
    }

    /**
     * Returns the self-peptide derived from the germline genome.
     *
     * @return the self-peptide derived from the germline genome.
     */
    public Peptide getSelfPeptide() {
        return selfPeptide.getPeptide();
    }

    /**
     * Returns the probability that the self-peptide would be generated
     * by proteasomal cleavage.
     *
     * @return the probability that the self-peptide would be generated
     * by proteasomal cleavage.
     */
    public Probability getSelfPeptideCleavageProb() {
        return selfCleaveProb;
    }

    @Override public String toString() {
        LineBuilder builder = new LineBuilder("\n");

        builder.append("MissChopRecord:");
        builder.append("  tumorBarcode   = " + tumorBarcode.getKey());
        builder.append("  hugoSymbol     = " + hugoSymbol.getKey());
        builder.append("  proteinChange  = " + proteinChange.format());
        builder.append("  neoPepMissPos  = " + Integer.toString(neoPepMissPos.getUnitIndex()));
        builder.append("  neoPepRange    = " + neoPepRange.format());
        builder.append("  neoPeptide     = " + neoPeptide.getPeptide().formatString());
        builder.append("  selfPeptide    = " + selfPeptide.getPeptide().formatString());
        builder.append("  neoCleaveProb  = " + neoCleaveProb);
        builder.append("  selfCleaveProb = " + selfCleaveProb);

        return builder.toString();
    }
}
